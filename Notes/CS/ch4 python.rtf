{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.17134}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9\par
\par
Chapter 4\par
Conditionals and recursion\par
4.1 The modulus operator\par
The modulus operator works on integers (and integer expressions) and yields the remainder when the first operand is divided by the second. In Python, the modulus operator is a percent sign (%). The syntax is the same as for other operators: \par
>>> quotient = 7 / 3 \par
>>> print quotient \par
2 \par
>>> remainder = 7 % 3 \par
>>> print remainder \par
1 \par
So 7 divided by 3 is 2 with 1 left over. \par
The modulus operator turns out to be surprisingly useful. For example, you can check whether one number is divisible by another     if x % y is zero, then x is divisible by y. \par
Also, you can extract the right-most digit or digits from a number. For example, x % 10 yields the right-most digit of x (in base 10). Similarly x % 100 yields the last two digits. \par
4.2 Boolean expressions\par
A boolean expression is an expression that is either true or false. One way to write a boolean expression is to use the operator ==, which compares two values and produces a boolean value: \par
>>> 5 == 5 \par
True \par
>>> 5 == 6 \par
False \par
In the first statement, the two operands are equal, so the value of the expression is True; in the second statement, 5 is not equal to 6, so we get False. True and False are special values that are built into Python. \par
The == operator is one of the comparison operators; the others are: \par
      x != y               # x is not equal to y \par
      x > y                # x is greater than y \par
      x < y                # x is less than y \par
      x >= y               # x is greater than or equal to y \par
      x <= y               # x is less than or equal to y \par
Although these operations are probably familiar to you, the Python symbols are different from the mathematical symbols. A common error is to use a single equal sign (=) instead of a double equal sign (==). Remember that = is an assignment operator and == is a comparison operator. Also, there is no such thing as =< or =>. \par
4.3 Logical operators\par
There are three logical operators: and, or, and not. The semantics (meaning) of these operators is similar to their meaning in English. For example, x > 0 and x < 10 is true only if x is greater than 0 and less than 10. \par
n%2 == 0 or n%3 == 0 is true if either of the conditions is true, that is, if the number is divisible by 2 or 3. \par
Finally, the not operator negates a boolean expression, so not(x > y) is true if (x > y) is false, that is, if x is less than or equal to y. \par
Strictly speaking, the operands of the logical operators should be boolean expressions, but Python is not very strict. Any nonzero number is interpreted as "true." \par
>>>  x = 5 \par
>>>  x and 1 \par
1 \par
>>>  y = 0 \par
>>>  y and 1 \par
0 \par
In general, this sort of thing is not considered good style. If you want to compare a value to zero, you should do it explicitly. \par
4.4 Conditional execution\par
In order to write useful programs, we almost always need the ability to check conditions and change the behavior of the program accordingly. Conditional statements give us this ability. The simplest form is the if statement: \par
if x > 0: \par
  print "x is positive" \par
The boolean expression after the if statement is called the condition. If it is true, then the indented statement gets executed. If not, nothing happens. \par
Like other compound statements, the if statement is made up of a header and a block of statements: \par
HEADER: \par
  FIRST STATEMENT \par
  ... \par
  LAST STATEMENT \par
The header begins on a new line and ends with a colon (:). The indented statements that follow are called a block. The first unindented statement marks the end of the block. A statement block inside a compound statement is called the body of the statement. \par
There is no limit on the number of statements that can appear in the body of an if statement, but there has to be at least one. Occasionally, it is useful to have a body with no statements (usually as a place keeper for code you haven't written yet). In that case, you can use the pass statement, which does nothing. \par
4.5 Alternative execution\par
A second form of the if statement is alternative execution, in which there are two possibilities and the condition determines which one gets executed. The syntax looks like this: \par
if x%2 == 0: \par
  print x, "is even" \par
else: \par
  print x, "is odd" \par
If the remainder when x is divided by 2 is 0, then we know that x is even, and the program displays a message to that effect. If the condition is false, the second set of statements is executed. Since the condition must be true or false, exactly one of the alternatives will be executed. The alternatives are called branches, because they are branches in the flow of execution. \par
As an aside, if you need to check the parity (evenness or oddness) of numbers often, you might "wrap" this code in a function: \par
def printParity(x): \par
  if x%2 == 0: \par
    print x, "is even" \par
  else: \par
    print x, "is odd" \par
For any value of x, printParity displays an appropriate message. When you call it, you can provide any integer expression as an argument. \par
>>> printParity(17) \par
17 is odd \par
>>> y = 17 \par
>>> printParity(y+1) \par
18 is even \par
4.6 Chained conditionals\par
Sometimes there are more than two possibilities and we need more than two branches. One way to express a computation like that is a chained conditional: \par
if x < y: \par
  print x, "is less than", y \par
elif x > y: \par
  print x, "is greater than", y \par
else: \par
  print x, "and", y, "are equal" \par
elif is an abbreviation of "else if." Again, exactly one branch will be executed. There is no limit of the number of elif statements, but the last branch has to be an else statement: \par
if choice == 'A': \par
  functionA() \par
elif choice == 'B': \par
  functionB() \par
elif choice == 'C': \par
  functionC() \par
else: \par
  print "Invalid choice." \par
Each condition is checked in order. If the first is false, the next is checked, and so on. If one of them is true, the corresponding branch executes, and the statement ends. Even if more than one condition is true, only the first true branch executes. \par
As an exercise, wrap these examples in functions called compare(x, y) and dispatch(choice). \par
4.7 Nested conditionals\par
One conditional can also be nested within another. We could have written the trichotomy example as follows: \par
if x == y: \par
  print x, "and", y, "are equal" \par
else: \par
  if x < y: \par
    print x, "is less than", y \par
  else: \par
    print x, "is greater than", y \par
The outer conditional contains two branches. The first branch contains a simple output statement. The second branch contains another if statement, which has two branches of its own. Those two branches are both output statements, although they could have been conditional statements as well. \par
Although the indentation of the statements makes the structure apparent, nested conditionals become difficult to read very quickly. In general, it is a good idea to avoid them when you can. \par
Logical operators often provide a way to simplify nested conditional statements. For example, we can rewrite the following code using a single conditional: \par
if 0 < x: \par
  if x < 10: \par
    print "x is a positive single digit." \par
The print statement is executed only if we make it past both the conditionals, so we can use the and operator: \par
if 0 < x and x < 10: \par
  print "x is a positive single digit." \par
These kinds of conditions are common, so Python provides an alternative syntax that is similar to mathematical notation: \par
if 0 < x < 10: \par
  print "x is a positive single digit." \par
This condition is semantically the same as the compound boolean expression and the nested conditional. \par
4.8 The return statement\par
The return statement allows you to terminate the execution of a function before you reach the end. One reason to use it is if you detect an error condition: \par
import math \par
\par
def printLogarithm(x): \par
  if x <= 0: \par
    print "Positive numbers only, please." \par
    return \par
\par
  result = math.log(x) \par
  print "The log of x is", result \par
The function printLogarithm has a parameter named x. The first thing it does is check whether x is less than or equal to 0, in which case it displays an error message and then uses return to exit the function. The flow of execution immediately returns to the caller, and the remaining lines of the function are not executed. \par
Remember that to use a function from the math module, you have to import it. \par
4.9 Recursion\par
We mentioned that it is legal for one function to call another, and you have seen several examples of that. We neglected to mention that it is also legal for a function to call itself. It may not be obvious why that is a good thing, but it turns out to be one of the most magical and interesting things a program can do. For example, look at the following function: \par
def countdown(n): \par
  if n == 0: \par
    print "Blastoff!" \par
  else: \par
    print n \par
    countdown(n-1) \par
countdown expects the parameter, n, to be a positive integer. If n is 0, it outputs the word, "Blastoff!" Otherwise, it outputs n and then calls a function named countdown     itself     passing n-1 as an argument. \par
What happens if we call this function like this: \par
>>> countdown(3) \par
The execution of countdown begins with n=3, and since n is not 0, it outputs the value 3, and then calls itself... \par
The execution of countdown begins with n=2, and since n is not 0, it outputs the value 2, and then calls itself... \par
The execution of countdown begins with n=1, and since n is not 0, it outputs the value 1, and then calls itself... \par
The execution of countdown begins with n=0, and since n is 0, it outputs the word, "Blastoff!" and then returns. \par
The countdown that got n=1 returns. \par
The countdown that got n=2 returns. \par
The countdown that got n=3 returns. \par
And then you're back in __main__ (what a trip). So, the total output looks like this: \par
3 \par
2 \par
1 \par
Blastoff! \par
As a second example, look again at the functions newLine and threeLines: \par
def newline(): \par
  print \par
\par
def threeLines(): \par
  newLine() \par
  newLine() \par
  newLine() \par
Although these work, they would not be much help if we wanted to output 2 newlines, or 106. A better alternative would be this: \par
def nLines(n): \par
  if n > 0: \par
    print \par
    nLines(n-1) \par
This program is similar to countdown; as long as n is greater than 0, it outputs one newline and then calls itself to output n-1 additional newlines. Thus, the total number of newlines is 1 + (n - 1) which, if you do your algebra right, comes out to n. \par
The process of a function calling itself is recursion, and such functions are said to be recursive. \par
4.10 Stack diagrams for recursive functions\par
In Section 3.11, we used a stack diagram to represent the state of a program during a function call. The same kind of diagram can help interpret a recursive function. \par
Every time a function gets called, Python creates a new function frame, which contains the function's local variables and parameters. For a recursive function, there might be more than one frame on the stack at the same time. \par
This figure shows a stack diagram for countdown called with n = 3: \par
\par
As usual, the top of the stack is the frame for __main__. It is empty because we did not create any variables in __main__ or pass any arguments to it. \par
The four countdown frames have different values for the parameter n. The bottom of the stack, where n=0, is called the base case. It does not make a recursive call, so there are no more frames. \par
As an exercise, draw a stack diagram for nLines called with n=4. \par
4.11 Infinite recursion\par
If a recursion never reaches a base case, it goes on making recursive calls forever, and the program never terminates. This is known as infinite recursion, and it is generally not considered a good idea. Here is a minimal program with an infinite recursion: \par
def recurse(): \par
  recurse() \par
In most programming environments, a program with infinite recursion does not really run forever. Python reports an error message when the maximum recursion depth is reached: \par
  File "<stdin>", line 2, in recurse \par
  (98 repetitions omitted) \par
  File "<stdin>", line 2, in recurse \par
RuntimeError: Maximum recursion depth exceeded \par
This traceback is a little bigger than the one we saw in the previous chapter. When the error occurs, there are 100 recurse frames on the stack! \par
As an exercise, write a function with infinite recursion and run it in the Python interpreter. \par
4.12 Keyboard input\par
The programs we have written so far are a bit rude in the sense that they accept no input from the user. They just do the same thing every time. \par
Python provides built-in functions that get input from the keyboard. The simplest is called raw_input. When this function is called, the program stops and waits for the user to type something. When the user presses Return or the Enter key, the program resumes and raw_input returns what the user typed as a string: \par
>>> input = raw_input () \par
What are you waiting for? \par
>>> print input \par
What are you waiting for? \par
Before calling raw_input, it is a good idea to print a message telling the user what to input. This message is called a prompt. We can supply a prompt as an argument to raw_input: \par
>>> name = raw_input ("What...is your name? ") \par
What...is your name? Arthur, King of the Britons! \par
>>> print name \par
Arthur, King of the Britons! \par
If we expect the response to be an integer, we can use the input function: \par
prompt = "What...is the airspeed velocity of an unladen swallow?\\n" \par
speed = input(prompt) \par
The sequence \\n at the end of the string represents a newline, so the user's input appears below the prompt. \par
If the user types a string of digits, it is converted to an integer and assigned to speed. Unfortunately, if the user types a character that is not a digit, the program crashes: \par
>>> speed = input (prompt) \par
What...is the airspeed velocity of an unladen swallow? \par
What do you mean, an African or a European swallow? \par
SyntaxError: invalid syntax \par
To avoid this kind of error, it is generally a good idea to use raw_input to get a string and then use conversion functions to convert to other types. \par
4.13 Glossary\par
modulus operator\par
An operator, denoted with a percent sign (%), that works on integers and yields the remainder when one number is divided by another.\par
boolean expression\par
An expression that is either true or false.\par
comparison operator\par
One of the operators that compares two values: ==, !=, >, <, >=, and <=.\par
logical operator\par
One of the operators that combines boolean expressions: and, or, and not.\par
conditional statement\par
A statement that controls the flow of execution depending on some condition.\par
condition\par
The boolean expression in a conditional statement that determines which branch is executed.\par
compound statement\par
A statement that consists of a header and a body. The header ends with a colon (:). The body is indented relative to the header.\par
block\par
A group of consecutive statements with the same indentation.\par
body\par
The block in a compound statement that follows the header.\par
nesting\par
One program structure within another, such as a conditional statement inside a branch of another conditional statement.\par
recursion\par
The process of calling the function that is currently executing.\par
base case\par
A branch of the conditional statement in a recursive function that does not result in a recursive call.\par
infinite recursion\par
A function that calls itself recursively without ever reaching the base case. Eventually, an infinite recursion causes a runtime error.\par
prompt\par
A visual cue that tells the user to input data.\par
This is an older version of the book now known as Think Python. You might prefer to read a more recent version. \par
\par
\par
\par
\par
How to Think Like a Computer Scientist\par
\par
}
 